# DI Compatibility — @teqfw/di

Path: `./ctx/docs/code/di-compatibility.md`

## Назначение

Документ фиксирует **жёсткие инженерные инварианты организации кода**, необходимые для признания кодовой базы **совместимой с DI-моделью `@teqfw/di`** в рамках проекта Mindstream.

Документ носит **нормативный характер**. Любое отклонение от зафиксированных положений считается **архитектурным дефектом**.

Документ не является руководством по использованию `@teqfw/di` и не дублирует README библиотеки.

---

## Роль DI в проекте

В проекте Mindstream:

- `@teqfw/di` является **единственным допустимым механизмом связывания project-кода**;
- DI используется как **основная форма композиции**, а не как вспомогательный инструмент;
- все зависимости между модулями выражаются **исключительно декларативно**, через Dependency IDs.

Код, обходящий DI-модель, **не считается частью корректной кодовой базы проекта**.

---

## Пространства имён и зоны кода

В проекте зафиксирован **строго ограниченный набор корневых namespace**:

- `Mindstream_Back_`
- `Mindstream_Shared_`
- `Mindstream_Web_`

Использование иных корневых namespace в MVP **запрещено**.

### Семантика зон

- `Back` — серверная логика и backend-службы.
- `Web` — клиентская логика и фронтенд-исполнение.
- `Shared` — platform-agnostic код.

`Mindstream_Shared_`:

- не имеет доступа к platform API;
- не использует `node:*`, DOM, `fetch`, `process` и аналогичные зависимости;
- содержит DTO, утилиты и чистую бизнес-логику.

---

## Импорт и связывание кода

### Запрещено

В любом business-модуле **запрещено**:

- статически импортировать project-код;
- использовать относительные импорты вида `../X.mjs`;
- напрямую импортировать platform API;
- напрямую импортировать зависимости из `node_modules`.

### Допустимо

- Все зависимости объявляются **исключительно через DI**;
- доступ к platform API и `node_modules` осуществляется **только через Dependency IDs**.

Нарушение любого из правил считается архитектурным дефектом.

---

## Зависимости из node_modules

Все зависимости, поставляемые через `node_modules`, в проекте Mindstream:

- **оформляются как ES6-модули**;
- **регистрируются в DI-контейнере с префиксом `node:`**;
- **внедряются в конструкторы или фабрики как готовые модули**, без обёрток и проксирования.

Нормативная форма dependency ID:

- `"node:<package-name>"`

Нормативная форма внедрения:

- зависимость передаётся в конструктор или фабрику как ES6-модуль
  (например: `"node:knex" → knex`).

Использование зависимостей из `node_modules`:

- без префикса `node:`;
- через статический `import` в business-коде;
- через динамический `require`;
- через контейнер как service locator;

**запрещено и считается архитектурным дефектом**.

---

## Composition Root

### Количество и роль

В проекте зафиксированы следующие production composition root:

- один для `Back`;
- один для `Web`;
- один для Service Worker.

Тесты используют **отдельный composition root**, создаваемый для набора тестов или для каждого unit-теста.

### Полномочия composition root

Только composition root имеет право:

- использовать статические импорты project-кода;
- использовать статические импорты зависимостей из `node_modules`;
- регистрировать зависимости с префиксом `node:`;
- конфигурировать namespace resolver;
- определять соответствие namespace ↔ filesystem;
- выполнять разрешение Dependency IDs в реальные объекты.

Любая конфигурация DI вне composition root **запрещена**.

---

## Запрет service locator

DI-контейнер (`Container`) является **инфраструктурным объектом** и **не относится к предметной модели** приложения.

В проекте Mindstream **запрещено**:

- передавать контейнер DI через параметры функций, конструкторов или методов;
- хранить контейнер (или его обёртки) в свойствах объектов;
- использовать контейнер для динамического извлечения зависимостей (`container.get(...)`) вне composition root и test mode;
- строить бизнес-логику, зависящую от наличия контейнера как сервиса.

**Любая сигнатура, принимающая `Container` или совместимый объект, считается архитектурным дефектом без обсуждений.**

---

## Нормативная модель зависимости

В корректной DI-модели проекта Mindstream:

- объект **не знает**, откуда берутся его зависимости;
- объект **не управляет** их созданием и жизненным циклом;
- все зависимости объекта:
  - выражены **явно**;
  - заданы **декларативно** через Dependency IDs;
  - разрешаются **до начала исполнения бизнес-логики**.

Если объекту требуется доступ к DI-контейнеру, это трактуется как дефект архитектуры.

---

## Factory-объекты

Factory-объекты допускаются как элемент композиции, но:

- принимают **только конкретные зависимости**, а не контейнер;
- не разрешают зависимости динамически;
- не выступают прокси-доступом к контейнеру.

Factory-объект создаёт объекты, но **не участвует в разрешении графа зависимостей**.

Нарушение любого пункта считается архитектурным дефектом.

---

## Dependency ID Model

### Суффиксы

Использование суффиксов `$` / `$$` является **обязательным**:

- `$` — singleton из default export;
- `$$` — новый экземпляр из default export;
- отсутствие суффикса — raw module / export без инстанцирования.

### Экспорты

- Нормативная форма — `default export`.
- `.export` допустим, но не является базовым путём.
- `(factory)` и `(proxy)` не входят в базовый MVP-набор.

---

## Platform Dependencies

- Dependency IDs с префиксом `node:` допустимы **только в `Mindstream_Back_`**.
- `Web` и `Shared` не используют platform-specific dependency IDs.
- Любой доступ к платформе осуществляется только через DI.

---

## Test Mode

`enableTestMode()` определяет разрешённость вмешательства в DI-граф.

В test mode допускается:

- регистрация и переопределение любых зависимостей;
- мокирование `node:*` зависимостей.

Вне test mode любые такие действия запрещены.

---

## Критерий совместимости

Код считается **совместимым с `@teqfw/di` в рамках проекта Mindstream** только при **одновременном соблюдении всех положений** данного документа.

Любое нарушение фиксируется как **архитектурный дефект** и не подлежит интерпретации.
