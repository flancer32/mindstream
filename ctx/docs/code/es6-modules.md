# ES6 Module Form — @teqfw/di

Path: `./ctx/docs/code/es6-modules.md`

## Назначение

Документ фиксирует **нормативную форму ES6-модулей проекта Mindstream**, используемых совместно с DI-контейнером `@teqfw/di`.

Документ определяет обязательную форму модуля, структуру конструктора, модель инкапсуляции и правила формирования публичного API экземпляра.

Документ относится к **кодовому слою** (`code/`) и описывает инженерную форму реализации.  
Он не описывает архитектуру, продуктовые смыслы, правила связывания зависимостей или конфигурацию DI-графа (см. `di-compatibility.md`).

---

## Нормативная форма модуля

Единственной допустимой формой ES6-модуля проекта Mindstream является:

- ES6-модуль;
- `default export`;
- экспортируемый объект — **`class`**.

Использование factory-функций в качестве default export **запрещено**, даже если они функционально эквивалентны классу.

Отсутствие `class` в default export трактуется как нарушение нормативной формы кодового слоя.

---

## Типовой шаблон модуля

Нормативный пример ES6-модуля, совместимого с `@teqfw/di`:

```js
/**
 * @module Namespace_Area_Module
 * @description Standard ES6 module for the DI container.
 */
export default class Namespace_Area_Module {
  constructor({ "node:http": http, Namespace_Area_Defaults$: DEF }) {
    const server = http.createServer();

    this.start = async function (cfg) {
      server.listen(cfg?.port ?? DEF.PORT);
    };

    this.stop = async function () {
      if (server) server.close();
    };
  }
}
```

Пример является **нормативным по форме**, а не рекомендацией по реализации логики.

---

## Конструктор и зависимости

- Конструктор принимает **ровно один аргумент** — объект зависимостей (`deps`).
- Зависимости объявляются **исключительно** через параметры конструктора.
- Доступ к зависимостям осуществляется через деструктурирование объекта `deps`.
- Конструктор **не проверяет** наличие зависимостей (`if (!deps)` и аналогичные проверки запрещены).

Контейнер `@teqfw/di` гарантирует корректность состава `deps`.
Любая проверочная или защитная логика в конструкторе считается дефектом.

Объект `deps` считается **логически неизменяемым** и не должен модифицироваться внутри конструктора.

---

## Инкапсуляция и состояние

Основным механизмом инкапсуляции данных и функций является **замыкание конструктора**.

Допускается и поощряется:

- хранение внутреннего состояния в локальных переменных конструктора;
- связывание функций с этим состоянием через замыкание.

Использование следующих механизмов **не требуется и не является нормативной практикой проекта**:

- `#private`-поля;
- `private`-модификаторы;
- защищённые поля и методы;
- сложные OO-иерархии.

Данная позиция обусловлена моделью DI и широким использованием singleton-компонентов в проекте.

---

## Публичный API экземпляра

- Все публичные методы экземпляра **объявляются исключительно через `this.` внутри конструктора**.
- Методы класса, объявленные вне конструктора, **запрещены**.
- Экземпляр модуля рассматривается как **собранный объект с явным API**, а не как классическая объектная иерархия.

Любое поведение, не добавленное через `this.` в конструкторе, считается недоступным и не должно использоваться как часть контракта модуля.

---

## Классы и объектная модель

Использование `class` является **обязательным** и носит формальный характер.

Класс используется исключительно как:

- контейнер формы модуля;
- носитель конструктора, вызываемого DI-контейнером.

Класс **не используется** как средство:

- наследования;
- полиморфизма;
- расширяемых иерархий;
- повторного использования поведения через `extends`.

Использование `extends`, `super` и построение цепочек наследования считается нарушением нормативной формы.

---

## Top-level логика модуля

Наличие top-level кода в ES6-модуле **допускается**, при соблюдении всех условий:

- код не создаёт side effects;
- код не обращается к platform API;
- код не инициирует выполнение прикладной логики до создания экземпляра через DI.

Любая инициализация, влияющая на поведение модуля, должна происходить внутри конструктора.

---

## Ограничения и запреты

В рамках проекта Mindstream для ES6-модулей **запрещено**:

- использование factory-функций вместо class;
- объявление публичных методов вне конструктора;
- изменение объекта `deps`;
- статический импорт project-кода вне composition root;
- использование private-модификаторов как основного механизма инкапсуляции;
- построение OO-иерархий и наследования.

---

## Статус требований

Положения данного документа являются **жёсткими инженерными инвариантами** кодового слоя проекта Mindstream.

Код, нарушающий зафиксированную форму ES6-модуля:

- считается **несовместимым с кодовым слоем проекта**;
- трактуется как дефект кодовой базы;
- не рассматривается как допустимое стилевое отклонение или технический долг.
