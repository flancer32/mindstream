# Расчёт и использование interest vector на фронте

Path: `./ctx/docs/composition/attention/interest-vector.md`

## Назначение

Данный документ описывает **прикладную композицию** расчёта и использования interest vector во фронтенд-приложении Mindstream.

Документ фиксирует:

- порядок и моменты обновления interest vector;
- режим его хранения и восстановления;
- правила применения interest vector при оценке публикаций;
- границы взаимодействия attention-модуля с UI.

Смысл и архитектурные инварианты interest vector определены в документе  
`ctx/docs/architecture/attention/interest-vector.md` и здесь не дублируются.

---

## Роль interest vector во фронтенд-композиции

Interest vector является:

- внутренним состоянием attention-модуля;
- локальным и неканоническим прикладным состоянием;
- агрегированной производной пользовательских сигналов внимания.

Interest vector **не является** частью глобального UI-состояния и **не экспонируется напрямую** во внешние компоненты.

---

## Инициализация

При старте фронтенд-приложения:

- attention-модуль пытается восстановить interest vector из локального хранилища браузера;
- если сохранённые данные отсутствуют, interest vector инициализируется как нулевой.

Инициализация:

- не использует исторические сигналы внимания;
- не выполняет фоновых вычислений;
- не инициирует серверных запросов.

---

## Обновление interest vector

### Триггеры обновления

Interest vector обновляется **строго по событиям внимания пользователя**, а именно:

- открытие обзора публикации;
- переход по ссылке на источник;
- последовательность «открытие обзора → переход по ссылке».

Фоновые или периодические обновления **не допускаются**.

---

### Порядок обновления

При каждом событии внимания:

1. Выполняется обновление interest vector.
2. Выполняется пересчёт оценок публикаций относительно обновлённого interest vector.
3. Результаты оценок кэшируются до следующего события внимания.

---

## Агрегация вкладов

### Общий принцип

Interest vector является **нормализованным агрегированным представлением** интересов пользователя в общем семантическом пространстве.

Новый вклад:

- всегда добавляется к текущему interest vector;
- после добавления выполняется нормализация вектора;
- рост вектора не допускается без нормализации.

---

### Комбинированные сигналы

Сценарий «обзор + переход по ссылке» трактуется как **два последовательных вклада**:

1. вклад от открытия обзора;
2. вклад от перехода по ссылке.

При этом:

- вклад перехода после обзора имеет больший приоритет, чем вклад одиночного перехода;
- это отражает снижение влияния случайных кликов по ссылке.

---

## Устаревание (decay)

В рамках MVP:

- interest vector накапливается и нормализуется;
- явная механика устаревания вкладов **может отсутствовать**.

Архитектурно допускается, что:

- без хранения статистики вкладов interest vector со временем стабилизируется в точке актуальных интересов пользователя;
- механизмы устаревания могут быть добавлены позже без изменения внешней композиции.

Если устаревание применяется:

- оно выполняется **при обновлении interest vector**;
- не требует фоновых процессов;
- не фиксируется численно на уровне композиции.

---

## Использование interest vector

Interest vector используется attention-модулем для:

- оценки потенциального интереса пользователя к каждой публикации;
- сортировки элементов персональной ленты;
- отсечения публикаций с недостаточной релевантностью.

Оценки:

- пересчитываются при каждом обновлении interest vector;
- кэшируются до следующего события внимания;
- используются UI без прямого доступа к interest vector.

---

## Взаимодействие с UI

Interest vector:

- является скрытым внутренним состоянием attention-модуля;
- не читается UI напрямую;
- не используется компонентами UI для собственной логики.

UI взаимодействует с attention-модулем **только через результаты оценки публикаций**, такие как:

- отсортированный список;
- приоритеты;
- отфильтрованные элементы.

---

## Персистентность

Interest vector:

- сохраняется локально во фронтенд-контексте;
- переживает перезапуск браузера;
- может быть утрачeн при ручной очистке пользовательских хранилищ.

Метаданные (например, timestamp последнего обновления):

- считаются внутренней деталью реализации;
- не фиксируются на уровне композиции.

---

## Сброс interest vector

В рамках MVP допускается:

- ручной сброс interest vector пользователем.

Сброс:

- приводит к инициализации interest vector в нулевое состояние;
- не требует серверного взаимодействия;
- не нарушает целостность системы.

---

## Границы ответственности

Данный документ:

- не описывает форматы хранения;
- не описывает структуры данных;
- не содержит формул или численных коэффициентов.

Документ фиксирует **порядок действий и режимы прикладной логики фронта**, оставаясь в границах композиционного уровня.
